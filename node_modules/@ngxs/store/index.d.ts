import * as i0 from '@angular/core';
import { Type, ModuleWithProviders, Signal, EnvironmentProviders } from '@angular/core';
import { ɵSharedSelectorOptions as _SharedSelectorOptions, ɵStateClass as _StateClass, ɵActionOptions as _ActionOptions, StateToken, ɵStoreOptions as _StoreOptions } from '@ngxs/store/internals';
export { ɵActionOptions as ActionOptions, StateToken } from '@ngxs/store/internals';
import * as rxjs from 'rxjs';
import { Observable, Subscription, OperatorFunction } from 'rxjs';
import { StateOperator } from '@ngxs/store/operators';
export { StateOperator } from '@ngxs/store/operators';
import { NgxsPlugin, NgxsPluginFn } from '@ngxs/store/plugins';
export { InitState, NGXS_PLUGINS, NgxsNextPluginFn, NgxsPlugin, NgxsPluginFn, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';

interface NgxsExecutionStrategy {
    enter<T>(func: () => T): T;
    leave<T>(func: () => T): T;
}

/**
 * The NGXS config settings.
 */
declare class NgxsConfig {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * Note: this property will be accounted only in development mode.
     * It makes sense to use it only during development to ensure there're no state mutations.
     * When building for production, the `Object.freeze` will be tree-shaken away.
     */
    developmentMode: boolean;
    compatibility: {
        /**
         * Support a strict Content Security Policy.
         * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.
         * (default: false)
         */
        strictContentSecurityPolicy: boolean;
    };
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `store.selectSignal(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     */
    executionStrategy: Type<NgxsExecutionStrategy>;
    /**
     * Defining shared selector options
     */
    selectorOptions: _SharedSelectorOptions;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsConfig, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsConfig>;
}

/**
 * State context provided to the actions in the state.
 */
interface StateContext<T> {
    /**
     * Get the current state.
     */
    getState(): T;
    /**
     * Reset the state to a new value.
     */
    setState(val: T | StateOperator<T>): void;
    /**
     * Patch the existing state with the provided value.
     */
    patchState(val: Partial<T>): void;
    /**
     * Dispatch a new action and return the dispatched observable.
     */
    dispatch(actions: any | any[]): Observable<void>;
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 */
declare class NgxsSimpleChange<T = any> {
    readonly previousValue: T;
    readonly currentValue: T;
    readonly firstChange: boolean;
    constructor(previousValue: T, currentValue: T, firstChange: boolean);
}
/**
 * On init interface
 */
interface NgxsOnInit {
    ngxsOnInit(ctx: StateContext<any>): void;
}
/**
 * On change interface
 */
interface NgxsOnChanges {
    ngxsOnChanges(change: NgxsSimpleChange): void;
}
/**
 * After bootstrap interface
 */
interface NgxsAfterBootstrap {
    ngxsAfterBootstrap(ctx: StateContext<any>): void;
}
type NgxsModuleOptions = Partial<NgxsConfig>;

/**
 * @ignore
 */
declare class NgxsRootModule {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsRootModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsRootModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsRootModule>;
}

/**
 * @ignore
 */
declare class NgxsFeatureModule {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsFeatureModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsFeatureModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsFeatureModule>;
}

declare class NgxsModule {
    static forRoot(states?: _StateClass[], options?: NgxsModuleOptions): ModuleWithProviders<NgxsRootModule>;
    static forFeature(states?: _StateClass[]): ModuleWithProviders<NgxsFeatureModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsModule>;
}

interface ActionDef<TArgs extends any[] = any[], TReturn = any> {
    type: string;
    new (...args: TArgs): TReturn;
}
type ActionType = ActionDef | {
    type: string;
};

/**
 * Given an action class, returns its payload.
 */
type ActionToPayload<Action extends ActionType> = Action extends ActionDef<any, infer ActionPayload> ? ActionPayload : never;
/**
 * Given a list of action classes, returns the union of their payloads.
 */
type ActionsToPayload<Actions extends readonly ActionType[]> = {
    [K in keyof Actions]: ActionToPayload<Actions[K]>;
}[number];
/**
 * Given an action class or a list of action classes, returns the union of their payloads.
 */
type ActionOrActionsToPayload<ActionOrActions> = ActionOrActions extends ActionType ? ActionToPayload<ActionOrActions> : ActionOrActions extends ActionType[] ? ActionsToPayload<ActionOrActions> : never;
/**
 * Describes what methods can be decorated with an `@Action` decorator that has been passed the given action(s).
 */
type HandlerTypedPropertyDescriptor<ActionOrActions> = TypedPropertyDescriptor<() => any> | TypedPropertyDescriptor<(stateContext: StateContext<any>) => any> | TypedPropertyDescriptor<(stateContext: StateContext<any>, action: ActionOrActionsToPayload<ActionOrActions>) => any>;
/**
 * The result of a call to the `@Action()` decorator with the given action(s) as its first argument.
 */
type ActionDecorator<ActionOrActions extends ActionType | ActionType[]> = (target: any, name: string | symbol, _descriptor: HandlerTypedPropertyDescriptor<ActionOrActions>) => void;
/**
 * Decorates a method with action information.
 */
declare function Action<ActionOrActions extends ActionType | ActionType[]>(actions: ActionOrActions, options?: _ActionOptions): ActionDecorator<ActionOrActions>;

type ɵSelectorFunc<TModel> = (...arg: any[]) => TModel;
type TypedSelector<TModel> = StateToken<TModel> | ɵSelectorFunc<TModel>;
type ɵStateSelector = _StateClass<any>;
type ɵSelectorDef<TModel> = ɵStateSelector | TypedSelector<TModel>;
type ɵSelectorReturnType<T extends ɵSelectorDef<any>> = T extends StateToken<infer R1> ? R1 : T extends ɵSelectorFunc<infer R2> ? R2 : T extends _StateClass<any> ? any : never;

interface SelectorMap$1 {
    [key: string]: TypedSelector<any>;
}
type ModelSelector<T extends SelectorMap$1> = (...args: any[]) => MappedResult<T>;
type MappedResult<TSelectorMap> = {
    [P in keyof TSelectorMap]: TSelectorMap[P] extends TypedSelector<infer R> ? R : never;
};
declare function createModelSelector<T extends SelectorMap$1>(selectorMap: T): ModelSelector<T>;

type KeysToValues<T, Keys extends (keyof T)[]> = {
    [Index in keyof Keys]: Keys[Index] extends keyof T ? T[Keys[Index]] : never;
};
declare function createPickSelector<TModel, Keys extends (keyof TModel)[]>(selector: TypedSelector<TModel>, keys: [...Keys]): (...props: KeysToValues<TModel, Keys>) => Pick<TModel, Keys[number]>;

type PropertySelectors<TModel> = {
    [P in keyof NonNullable<TModel>]-?: (model: TModel) => TModel extends null | undefined ? undefined : NonNullable<TModel>[P];
};
declare function createPropertySelectors<TModel>(parentSelector: ɵSelectorDef<TModel>): PropertySelectors<TModel>;

interface CreationMetadata {
    containerClass: any;
    selectorName: string;
    getSelectorOptions?: () => _SharedSelectorOptions;
}

type SelectorArg = ɵSelectorDef<any>;
/**
 * Function for creating a selector
 * @param selectors The selectors to use to create the arguments of this function
 * @param originalFn The original function being made into a selector
 * @param creationMetadata
 */
declare function createSelector<S1 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>) => any>(selectors: [S1], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>) => any>(selectors: [S1, S2], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>) => any>(selectors: [S1, S2, S3], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>) => any>(selectors: [S1, S2, S3, S4], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>) => any>(selectors: [S1, S2, S3, S4, S5], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, S6 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>, s6: ɵSelectorReturnType<S6>) => any>(selectors: [S1, S2, S3, S4, S5, S6], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, S6 extends SelectorArg, S7 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>, s6: ɵSelectorReturnType<S6>, s7: ɵSelectorReturnType<S7>) => any>(selectors: [S1, S2, S3, S4, S5, S6, S7], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<S1 extends SelectorArg, S2 extends SelectorArg, S3 extends SelectorArg, S4 extends SelectorArg, S5 extends SelectorArg, S6 extends SelectorArg, S7 extends SelectorArg, S8 extends SelectorArg, TProjector extends (s1: ɵSelectorReturnType<S1>, s2: ɵSelectorReturnType<S2>, s3: ɵSelectorReturnType<S3>, s4: ɵSelectorReturnType<S4>, s5: ɵSelectorReturnType<S5>, s6: ɵSelectorReturnType<S6>, s7: ɵSelectorReturnType<S7>, s8: ɵSelectorReturnType<S8>) => any>(selectors: [S1, S2, S3, S4, S5, S6, S7, S8], projector: TProjector, creationMetadata?: Partial<CreationMetadata>): TProjector;
declare function createSelector<T extends (...args: any[]) => any>(selectors: SelectorArg[] | undefined, projector: T, creationMetadata?: Partial<CreationMetadata>): T;

type ActionOrArrayOfActions<T> = T extends (infer U)[] ? NonNullable<U>[] : NonNullable<T>;
declare class Store {
    private _stateStream;
    private _internalStateOperations;
    private _config;
    private _internalExecutionStrategy;
    private _stateFactory;
    /**
     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
     */
    private _selectableStateStream;
    constructor();
    /**
     * Dispatches action(s).
     */
    dispatch<T>(actionOrActions: ActionOrArrayOfActions<T>): Observable<void>;
    /**
     * Selects a slice of data from the store.
     */
    select<T>(selector: TypedSelector<T>): Observable<T>;
    /**
     * Select one slice of data from the store.
     */
    selectOnce<T>(selector: TypedSelector<T>): Observable<T>;
    /**
     * Select a snapshot from the state.
     */
    selectSnapshot<T>(selector: TypedSelector<T>): T;
    /**
     * Select a signal from the state.
     */
    selectSignal<T>(selector: TypedSelector<T>): Signal<T>;
    /**
     * Allow the user to subscribe to the root of the state
     */
    subscribe(fn?: (value: any) => void): Subscription;
    /**
     * Return the raw value of the state.
     */
    snapshot(): any;
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    reset(state: any): void;
    private getStoreBoundSelectorFn;
    private initStateStream;
    static ɵfac: i0.ɵɵFactoryDeclaration<Store, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<Store>;
}

/**
 * Decorates a class with ngxs state information.
 */
declare function State<T>(options: _StoreOptions<T>): (target: _StateClass) => void;

/**
 * Decorator for selecting a slice of state from the store.
 *
 * @deprecated
 * Read the deprecation notice at this link: https://ngxs.io/deprecations/select-decorator-deprecation.
 */
declare function Select<T>(rawSelector?: T, ...paths: string[]): PropertyDecorator;

/**
 * Decorator for setting selector options at a method or class level.
 */
declare function SelectorOptions(options: _SharedSelectorOptions): ClassDecorator & MethodDecorator;

/**
 * Status of a dispatched action
 */
declare const enum ActionStatus {
    Dispatched = "DISPATCHED",
    Successful = "SUCCESSFUL",
    Canceled = "CANCELED",
    Errored = "ERRORED"
}
interface ActionContext<T = any> {
    status: ActionStatus;
    action: T;
    error?: Error;
}
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
declare class Actions extends Observable<ActionContext> {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<Actions, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<Actions>;
}

type TupleKeys<T extends any[]> = Exclude<keyof T, keyof []>;
/**
 * Given a POJO, returns the POJO type, given a class constructor object, returns the type of the class.
 *
 * This utility type exists due to the complexity of ActionType being either an ActionDef class or the plain
 * `{ type: string }` type (or similar compatible POJO types).
 */
type Constructed<T> = T extends new (...args: any[]) => infer U ? U : T;
interface ActionCompletion<T = any, E = Error> {
    action: T;
    result: {
        successful: boolean;
        canceled: boolean;
        error?: E;
    };
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 */
declare function ofAction<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 */
declare function ofActionDispatched<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 */
declare function ofActionSuccessful<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 */
declare function ofActionCanceled<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, Constructed<T[TupleKeys<T>]>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been completed
 */
declare function ofActionCompleted<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, ActionCompletion<Constructed<T[TupleKeys<T>]>>>;
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 */
declare function ofActionErrored<T extends ActionType[]>(...allowedTypes: T): OperatorFunction<ActionContext<Constructed<T[TupleKeys<T>]>>, ActionCompletion<Constructed<T[TupleKeys<T>]>>>;

/**
 * Defines a tuple of selector functions, state tokens, and state classes that a selector decorated
 * by `@Selector()` can depend on.
 */
type SelectorDefTuple = ɵSelectorDef<any>[] | [ɵSelectorDef<any>];
type UnknownToAny<T> = unknown extends T ? any : T;
type EnsureArray<T> = T extends any[] ? T : never;
/**
 * Given a tuple of selector functions, state tokens, state classes, etc., returns a tuple of what
 * a dependent selector would expect to receive for that parent as an argument when called.
 *
 * For example, if the first element in `ParentsTuple` is a selector function that returns a
 * `number`, then the first element of the result tuple will be `number`. If the second element
 * in `ParentsTuple` is a state class with model `{ name: string }`, then the second element of
 * the result tuple will be `{ name: string }`.
 */
type SelectorReturnTypeList<ParentsTuple extends SelectorDefTuple> = EnsureArray<{
    [ParentsTupleIndex in keyof ParentsTuple]: ParentsTuple[ParentsTupleIndex] extends ɵSelectorDef<any> ? UnknownToAny<ɵSelectorReturnType<ParentsTuple[ParentsTupleIndex]>> : never;
}>;
/**
 * Defines a selector function matching a given argument list of parent selectors/states/tokens
 * and a given return type.
 */
type SelectorSpec<ParentsTuple, Return> = ParentsTuple extends [] ? () => any : ParentsTuple extends SelectorDefTuple ? (...states: SelectorReturnTypeList<ParentsTuple>) => Return : () => any;
/**
 * Defines a selector function matching `SelectorSpec<ParentsTuple, Return>` but with the assumption that the
 * container state has been injected as the first argument.
 */
type SelectorSpecWithInjectedState<ParentsTuple, Return> = SelectorSpec<ParentsTuple extends SelectorDefTuple ? [any, ...ParentsTuple] : [any], ParentsTuple extends SelectorDefTuple ? Return : any>;
/**
 * Defines a property descriptor for the `@Selector` decorator that decorates a function with
 * parent selectors/states/tokens `ParentsTuple` and return type `Return`.
 */
type DescriptorWithNoInjectedState<ParentsTuple, Return> = TypedPropertyDescriptor<SelectorSpec<ParentsTuple, Return>>;
/**
 * Same as `DescriptorWithNoInjectedState` but with state injected as the first argument.
 */
type DescriptorWithInjectedState<ParentsTuple, Return> = TypedPropertyDescriptor<SelectorSpecWithInjectedState<ParentsTuple, Return>>;
type DecoratorArgs<Descriptor> = [target: any, key: string | symbol, descriptor?: Descriptor];
/**
 * Defines the return type of a call to `@Selector` when there is no argument given
 * (e.g. `@Selector()` counts, but `@Selector([])` does not)
 *
 * This result is a decorator that can only be used to decorate a function with no arguments or a
 * single argument that is the container state.
 */
type SelectorTypeNoDecoratorArgs = {
    <Return>(...args: DecoratorArgs<DescriptorWithNoInjectedState<unknown, Return>>): void | DescriptorWithNoInjectedState<unknown, Return>;
    <Return>(...args: DecoratorArgs<DescriptorWithInjectedState<unknown, Return>>): void | DescriptorWithInjectedState<unknown, Return>;
};
/**
 * Defines the return type of a call to `@Selector` when there is an argument given.
 * (e.g. `@Selector([])` counts, but `@Selector()` does not)
 *
 * This result is a decorator that can only be used to decorate a function with an argument list
 * matching the results of the tuple of parents `ParentsTuple`.
 */
type SelectorTypeWithDecoratorArgs<ParentsTuple> = {
    <Return>(...args: DecoratorArgs<DescriptorWithNoInjectedState<ParentsTuple, Return>>): void | DescriptorWithNoInjectedState<ParentsTuple, Return>;
    /**
     * @deprecated
     * Read the deprecation notice at this link: https://ngxs.io/deprecations/inject-container-state-deprecation.md.
     */
    <Return>(...args: DecoratorArgs<DescriptorWithInjectedState<ParentsTuple, Return>>): void | DescriptorWithInjectedState<ParentsTuple, Return>;
};
/**
 * Defines the return type of a call to `@Selector`. This result is a decorator that can only be
 * used to decorate a function with an argument list matching `ParentsTuple`, the results of the
 * tuple of parent selectors/state tokens/state classes.
 */
type SelectorType<ParentsTuple> = unknown extends ParentsTuple ? SelectorTypeNoDecoratorArgs : SelectorTypeWithDecoratorArgs<ParentsTuple>;

/**
 * Decorator for creating a state selector for the current state.
 */
declare function Selector(): SelectorType<unknown>;
/**
 * Decorator for creating a state selector from the provided selectors (and optionally the container State, depending on the applicable Selector Options).
 */
declare function Selector<T extends SelectorDefTuple>(selectors: T): SelectorType<T>;

declare class NoopNgxsExecutionStrategy implements NgxsExecutionStrategy {
    enter<T>(func: () => T): T;
    leave<T>(func: () => T): T;
    static ɵfac: i0.ɵɵFactoryDeclaration<NoopNgxsExecutionStrategy, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NoopNgxsExecutionStrategy>;
}

interface NgxsUnhandledErrorContext {
    action: any;
}
declare class NgxsUnhandledErrorHandler {
    private _ngZone;
    private _errorHandler;
    /**
     * The `_unhandledErrorContext` is left unused internally since we do not
     * require it for internal operations. However, developers who wish to provide
     * their own custom error handler may utilize this context information.
     */
    handleError(error: any, _unhandledErrorContext: NgxsUnhandledErrorContext): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsUnhandledErrorHandler, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsUnhandledErrorHandler>;
}

interface NgxsDevelopmentOptions {
    warnOnUnhandledActions: true | {
        ignore: ActionType[];
    };
}

declare class NgxsDevelopmentModule {
    static forRoot(options: NgxsDevelopmentOptions): ModuleWithProviders<NgxsDevelopmentModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsDevelopmentModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxsDevelopmentModule, never, never, never>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxsDevelopmentModule>;
}
declare function withNgxsDevelopmentOptions(options: NgxsDevelopmentOptions): i0.EnvironmentProviders;

declare class NgxsUnhandledActionsLogger {
    /**
     * These actions should be ignored by default; the user can increase this
     * list in the future via the `ignoreActions` method.
     */
    private _ignoredActions;
    constructor();
    /**
     * Adds actions to the internal list of actions that should be ignored.
     */
    ignoreActions(...actions: ActionType[]): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxsUnhandledActionsLogger, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NgxsUnhandledActionsLogger>;
}

/**
 * This feature that contributes to app stability, which is required during
 * server-side rendering. With asynchronous actions being dispatched and handled,
 * Angular is unaware of them in zoneless mode and doesn't know whether the app is
 * still unstable. This may prematurely serialize the final HTML that is sent to the client.
 * Including `withNgxsPendingTasks` in your `provideStore` for your SSR
 * app will resolve the above issue.
 */
declare function withNgxsPendingTasks(): i0.EnvironmentProviders;

/**
 * This function provides global store providers and initializes the store.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [provideStore([CountriesState])]
 * });
 * ```
 *
 * The `provideStore` may be optionally called with a config before the list of features:
 *
 * ```ts
 * provideStore([CountriesState], {
 *   developmentMode: !environment.production
 * });
 * ```
 */
declare function provideStore(states?: _StateClass[], ...features: EnvironmentProviders[]): EnvironmentProviders;
declare function provideStore(states?: _StateClass[], options?: NgxsModuleOptions, ...features: EnvironmentProviders[]): EnvironmentProviders;

/**
 * This version serves as a standalone alternative to `NgxsModule.forFeature`.
 * It can be used in a similar manner to register feature states, but at the
 * `Route` providers level:
 *
 * ```ts
 * const routes: Routes = [
 *   {
 *     path: 'products',
 *     loadComponent: async () => {...},
 *     providers: [provideStates([ProductsState])]
 *   }
 * ];
 * ```
 */
declare function provideStates(states: _StateClass[], ...features: EnvironmentProviders[]): EnvironmentProviders;

/**
 * This function registers a custom global plugin for the state.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore(
 *       [CountriesState],
 *       withNgxsPlugin(LogoutPlugin)
 *     )
 *   ]
 * });
 * ```
 */
declare function withNgxsPlugin(plugin: Type<NgxsPlugin> | NgxsPluginFn): EnvironmentProviders;

/**
 * This function registers a preboot function which will be called before the root
 * store initializer is run, but after all of the NGXS features are provided and
 * available for injection. This is useful for registering action stream listeners
 * before any action is dispatched.
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore(
 *       [CountriesState],
 *       withNgxsPreboot(() => {
 *         const actions$ = inject(Actions);
 *         actions$.subscribe(ctx => console.log(ctx));
 *       })
 *     )
 *   ]
 * });
 * ```
 */
declare function withNgxsPreboot(prebootFn: VoidFunction): i0.EnvironmentProviders;

/**
 * This function serves as a utility and has multiple purposes.
 * Firstly, it allows you to select properties from the state class
 * without having to inject the store class and use `this.store.selectSignal`,
 * resulting in a more concise implementation. Secondly, it can be used with
 * other solutions such as NgRx signal store with its `signalStoreFeature` or
 * `withComputed` functionalities.
 *
 * Please note that it's named `select` instead of `selectSignal` because
 * signals are evolving into first-class primitives in Angular, displacing other
 * primitives such as observables. Observables represent a stream of events,
 * whereas signals represent a single value changing over time.
 */
declare function select<T>(selector: TypedSelector<T>): Signal<T>;

declare function dispatch<TArgs extends any[]>(ActionType: ActionDef<TArgs>): (...args: TArgs) => rxjs.Observable<void>;

type SelectorMap = Record<string, TypedSelector<unknown>>;
declare function createSelectMap<T extends SelectorMap>(selectorMap: T): { readonly [K in keyof T]: Signal<ɵSelectorReturnType<T[K]>>; };

type ActionMap = Record<string, ActionDef<any>>;
declare function createDispatchMap<T extends ActionMap>(actionMap: T): { readonly [K in keyof T]: (...args: ConstructorParameters<T[K]>) => Observable<void>; };

declare function ɵprovideNgxsInternalStateTokens(): i0.EnvironmentProviders;

export { Action, type ActionCompletion, type ActionContext, type ActionDef, type ActionMap, ActionStatus, type ActionType, Actions, type NgxsAfterBootstrap, NgxsConfig, NgxsDevelopmentModule, type NgxsDevelopmentOptions, type NgxsExecutionStrategy, NgxsModule, type NgxsModuleOptions, type NgxsOnChanges, type NgxsOnInit, NgxsSimpleChange, NgxsUnhandledActionsLogger, type NgxsUnhandledErrorContext, NgxsUnhandledErrorHandler, NoopNgxsExecutionStrategy, type PropertySelectors, Select, Selector, type SelectorMap, SelectorOptions, State, type StateContext, Store, type TypedSelector, createDispatchMap, createModelSelector, createPickSelector, createPropertySelectors, createSelectMap, createSelector, dispatch, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, provideStates, provideStore, select, withNgxsDevelopmentOptions, withNgxsPendingTasks, withNgxsPlugin, withNgxsPreboot, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule, type ɵSelectorDef, type ɵSelectorFunc, type ɵSelectorReturnType, type ɵStateSelector, ɵprovideNgxsInternalStateTokens };
