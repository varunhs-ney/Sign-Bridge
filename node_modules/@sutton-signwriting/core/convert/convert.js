/**
* Sutton SignWriting Core Module v2.0.0 (https://github.com/sutton-signwriting/core)
* Author: Steve Slevinski  (https://SteveSlevinski.me)
* convert.js is released under the MIT License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ssw = global.ssw || {}, global.ssw.convert = {})));
})(this, (function (exports) { 'use strict';

  /**
   * Object of regular expressions for FSW strings
   * 
   * @alias fsw.re
   * @property {string} null - the null symbol
   * @property {string} symbol - a symbol
   * @property {string} nullorsymbol - null or a symbol
   * @property {string} sort - the sorting marker
   * @property {string} prefix - a sorting marker followed by one or more symbols with nulls
   * @property {string} box - a signbox marker
   * @property {string} coord - a coordinate
   * @property {string} spatial - a symbol followed by a coordinate
   * @property {string} signbox - a signbox marker, max coordinate and zero or more spatial symbols
   * @property {string} sign - an optional prefix followed by a signbox
   * @property {string} sortable - a mandatory prefix followed by a signbox
   */
  let re$1 = {
    'null': 'S00000',
    'symbol': 'S[123][0-9a-f]{2}[0-5][0-9a-f]',
    'coord': '[0-9]{3}x[0-9]{3}',
    'sort': 'A',
    'box': '[BLMR]'
  };
  re$1.nullorsymbol = `(?:${re$1.null}|${re$1.symbol})`;
  re$1.prefix = `(?:${re$1.sort}${re$1.nullorsymbol}+)`;
  re$1.spatial = `${re$1.symbol}${re$1.coord}`;
  re$1.signbox = `${re$1.box}${re$1.coord}(?:${re$1.spatial})*`;
  re$1.sign = `${re$1.prefix}?${re$1.signbox}`;
  re$1.sortable = `${re$1.prefix}${re$1.signbox}`;

  /**
   * Object of regular expressions for SWU strings in UTF-16
   * 
   * @alias swu.re
   * @property {string} null - the null symbol
   * @property {string} symbol - a symbol
   * @property {string} nullorsymbol - null or a symbol
   * @property {string} sort - the sorting marker
   * @property {string} prefix - a sorting marker followed by one or more symbols with nulls
   * @property {string} box - a signbox marker
   * @property {string} coord - a coordinate
   * @property {string} spatial - a symbol followed by a coordinate
   * @property {string} signbox - a signbox marker, max coordinate and zero or more spatial symbols
   * @property {string} sign - an optional prefix followed by a signbox
   * @property {string} sortable - a mandatory prefix followed by a signbox
   */
  let re = {
    'null': '\uD8C0\uDC00',
    'symbol': '(?:(?:\uD8C0[\uDC01-\uDFFF])|(?:[\uD8C1-\uD8FC][\uDC00-\uDFFF])|(?:\uD8FD[\uDC00-\uDC80]))',
    'coord': '(?:\uD836[\uDC0C-\uDDFF]){2}',
    'sort': '\uD836\uDC00',
    'box': '\uD836[\uDC01-\uDC04]'
  };
  re.nullorsymbol = `(?:${re.null}|${re.symbol})`;
  re.prefix = `(?:${re.sort}(?:${re.nullorsymbol})+)`;
  re.spatial = `${re.symbol}${re.coord}`;
  re.signbox = `${re.box}${re.coord}(?:${re.spatial})*`;
  re.sign = `${re.prefix}?${re.signbox}`;
  re.sortable = `${re.prefix}${re.signbox}`;

  /**
   * An array of symbol IDs in minimized format such as "101011"
   * 
   * @alias convert.symidArr
   * @type {string[]}
   */
  const symidArr = ["101011", "101021", "101031", "101041", "101051", "101061", "101071", "101081", "101091", "101101", "101111", "101121", "101131", "101141", "102011", "102021", "102031", "102041", "102051", "102061", "102071", "102081", "102091", "102101", "102111", "102121", "102131", "102141", "102151", "102161", "103011", "103021", "103031", "103041", "103051", "103061", "103071", "103081", "103091", "103101", "103111", "103121", "103131", "103141", "103151", "103161", "103171", "103181", "103191", "103201", "103211", "103221", "103231", "103241", "103251", "103261", "103271", "103281", "103291", "103301", "103311", "103321", "103331", "103341", "103351", "103361", "103371", "103381", "104011", "104021", "104031", "104041", "104051", "104061", "104071", "104081", "105011", "105021", "105031", "105041", "105051", "105061", "105071", "105081", "105091", "105101", "105111", "105121", "105131", "105141", "105151", "105161", "105171", "105181", "105191", "105201", "105211", "105221", "105231", "105241", "105251", "105261", "105271", "105281", "105291", "105301", "105311", "105321", "105331", "105341", "105351", "105361", "105371", "105381", "105391", "105401", "105411", "105421", "105431", "105441", "105451", "105461", "105471", "105481", "105491", "105501", "105511", "105521", "105531", "105541", "105551", "105561", "105571", "105581", "106011", "106021", "106031", "106041", "106051", "106061", "106071", "106081", "106091", "106101", "106111", "106121", "106131", "106141", "106151", "106161", "106171", "106181", "106191", "106201", "106211", "106221", "106231", "106241", "106251", "106261", "106271", "106281", "106291", "106301", "107011", "107021", "107031", "107041", "107051", "107061", "107071", "107081", "107091", "107101", "107111", "107121", "107131", "107141", "107151", "107161", "107171", "107181", "107191", "107201", "107211", "107221", "108011", "108021", "108031", "108041", "108051", "108061", "108071", "108081", "108091", "108101", "108111", "108121", "108131", "108141", "108151", "108161", "108171", "108181", "108191", "109011", "109021", "109031", "109041", "109051", "109061", "109071", "109081", "109091", "109101", "109111", "109121", "109131", "109141", "109151", "109161", "109171", "109181", "109191", "109201", "109211", "109221", "109231", "109241", "109251", "109261", "109271", "109281", "109291", "109301", "109311", "109321", "109331", "109341", "109351", "109361", "109371", "109381", "109391", "109401", "110011", "110021", "110031", "110041", "110051", "110061", "110071", "110081", "110091", "110101", "110111", "110121", "110131", "110141", "110151", "110161", "201011", "201021", "201031", "201041", "201051", "201061", "201071", "201081", "201091", "201101", "201111", "201121", "201131", "201141", "201151", "201161", "201171", "202011", "202012", "202021", "202022", "202031", "202041", "202042", "202051", "202052", "202061", "202071", "202081", "202082", "202091", "202092", "202101", "202102", "202111", "202121", "202131", "203011", "203012", "203013", "203014", "203015", "203021", "203022", "203031", "203032", "203041", "203051", "203052", "203061", "203062", "203071", "203072", "203073", "203081", "203082", "203083", "203084", "203091", "203092", "203093", "203101", "203102", "203103", "203111", "203112", "203113", "203121", "203122", "203123", "203131", "203141", "203151", "203161", "203171", "203181", "203191", "203201", "203202", "203203", "204011", "204012", "204013", "204014", "204021", "204022", "204023", "204024", "204031", "204032", "204033", "204034", "204041", "204042", "204043", "204044", "205011", "205012", "205013", "205014", "205015", "205021", "205022", "205031", "205032", "205041", "205051", "205052", "205061", "205062", "205071", "205081", "205082", "205083", "205091", "205101", "205102", "205103", "205111", "205112", "205113", "205121", "205122", "205123", "205131", "205141", "205151", "205161", "205171", "205181", "205191", "206011", "206012", "206013", "206014", "206021", "206022", "206023", "206024", "206031", "206032", "206041", "206042", "206043", "206051", "206052", "206053", "206054", "206061", "206062", "206063", "206064", "206065", "206066", "206071", "206072", "206073", "206081", "206091", "206101", "206111", "207011", "207021", "207031", "207041", "207051", "207061", "207071", "207091", "207101", "207111", "207121", "207131", "207141", "207151", "207161", "207162", "207163", "208011", "208012", "208021", "208022", "208023", "208024", "208031", "208032", "208033", "208034", "208041", "208042", "208051", "208061", "208071", "208081", "208082", "208091", "208092", "208093", "208094", "208101", "208102", "208103", "208104", "208111", "208112", "208121", "208131", "208141", "209011", "209012", "209013", "209014", "209015", "209021", "209031", "209041", "209042", "209043", "209051", "209061", "209071", "209081", "210011", "210012", "210021", "210022", "210031", "210032", "210033", "210041", "210042", "210043", "210051", "210052", "210061", "210062", "210071", "210072", "210073", "210074", "210081", "210082", "301011", "301021", "301031", "301032", "301041", "301042", "301043", "301044", "401011", "401021", "401031", "401041", "401051", "401061", "401071", "401081", "401091", "401101", "401102", "402011", "402012", "402013", "402021", "402022", "402023", "402024", "402031", "402032", "402033", "402041", "402042", "402043", "402044", "402045", "402051", "402052", "402053", "402054", "402055", "402061", "402062", "402063", "402071", "402072", "402073", "402081", "402082", "402083", "402091", "402101", "402111", "403011", "403012", "403013", "403021", "403022", "403023", "403031", "403041", "403042", "403043", "403044", "403051", "403052", "403061", "403062", "403071", "403072", "404011", "404012", "404013", "404021", "404022", "404023", "404031", "404032", "404033", "404041", "404042", "404043", "404051", "404052", "404053", "404061", "404062", "404063", "404071", "404072", "404073", "404081", "404082", "404083", "404091", "404092", "404093", "404101", "404111", "404112", "405011", "405012", "405013", "405014", "405015", "405021", "405031", "405041", "405051", "405052", "405061", "405062", "405071", "405072", "405081", "405091", "405101", "405111", "405121", "405131", "501011", "501021", "501031", "501041", "501051", "501061", "501071", "501081", "501091", "502011", "502021", "502022", "502023", "502024", "502031", "502032", "502033", "502041", "601011", "601012", "601021", "601031", "601041", "601051", "601061", "601071", "701011", "701012", "701021", "701022", "701031"];

  /** The convert module contains functions to convert between Formal SignWriitng in ASCII (FSW) and SignWriting in Unicode (SWU) characters, along with other types of data.
   * [Characters set definitions](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-characters)
   * @module convert
   */

  /**
   * Function to convert an SWU structural marker to FSW equivalent
   * @function convert.swu2mark
   * @param {string} swuMark - character for SWU structural marker
   * @returns {string} FSW structural marker
   * @example
   * convert.swu2mark('ð €')
   * 
   * return 'A'
   */
  const swu2mark = swuMark => {
    return {
      'ð €': 'A',
      'ð ': 'B',
      'ð ‚': 'L',
      'ð ƒ': 'M',
      'ð „': 'R'
    }[swuMark];
  };

  /**
   * Function to convert an FSW structural marker to SWU equivalent
   * @function convert.mark2swu
   * @param {string} fswMark - character for FSW structural marker
   * @returns {string} SWU structural marker
   * @example
   * convert.mark2swu('A')
   * 
   * return 'ð €'
   */
  const mark2swu = fswMark => {
    return {
      'A': 'ð €',
      'B': 'ð ',
      'L': 'ð ‚',
      'M': 'ð ƒ',
      'R': 'ð „'
    }[fswMark];
  };

  /**
   * Function to convert an SWU number character to an integer
   * @function convert.swu2num
   * @param {string} swuNum - SWU number character
   * @returns {number} Integer value for number
   * @example
   * convert.swu2num('ð¤†')
   * 
   * return 500
   */
  const swu2num = swuNum => parseInt(swuNum.codePointAt(0)) - 0x1D80C + 250;

  /**
   * Function to convert a number to an SWU number character
   * @function convert.num2swu
   * @param {number} num - Integer value for number
   * @returns {string} SWU number character
   * @example
   * convert.num2swu(500)
   * 
   * return 'ð¤†'
   */
  const num2swu = num => String.fromCodePoint(0x1D80C + parseInt(num) - 250);

  /**
   * Function to convert two SWU number characters to an array of x,y integers
   * @function convert.swu2coord
   * @param {string} swuCoord - Two SWU number character
   * @returns {number[]} Array of x,y integers
   * @example
   * convert.swu2coord('ð¤†ð¤†')
   * 
   * return [500, 500]
   */
  const swu2coord = swuCoord => [swu2num(swuCoord.slice(0, 2)), swu2num(swuCoord.slice(2, 4))];

  /**
   * Function to convert an array of x,y integers to two SWU number characters
   * @function convert.coord2swu
   * @param {number[]} coord - Array of x,y integers
   * @returns {string} Two SWU number character
   * @example
   * convert.coord2swu([500, 500])
   * 
   * return 'ð¤†ð¤†'
   */
  const coord2swu = coord => coord.map(num => num2swu(num)).join('');

  /**
   * Function to convert an FSW coordinate string to an array of x,y integers
   * @function convert.fsw2coord
   * @param {string} fswCoord - An FSW coordinate string
   * @returns {number[]} Array of x,y integers
   * @example
   * convert.fsw2coord('500x500')
   * 
   * return [500, 500]
   */
  const fsw2coord = fswCoord => fswCoord.split('x').map(num => parseInt(num));

  /**
   * Function to convert an array of x,y integers to an FSW coordinate string
   * @function convert.coord2fsw
   * @param {number[]} coord - Array of x,y integers
   * @returns {string} An FSW coordinate string
   * @example
   * convert.coord2fsw([500, 500])
   * 
   * return '500x500'
   */
  const coord2fsw = coord => coord.join('x');

  /**
   * Function to convert an SWU symbol character to a code point on plane 4
   * @function convert.swu2code
   * @param {string} swuSym - SWU symbol character
   * @returns {number} Code point on plane 4
   * @example
   * convert.swu2code('ñ€€')
   * 
   * return 0x40001
   */
  const swu2code = swuSym => parseInt(swuSym.codePointAt(0));

  /**
   * Function to convert a code point on plane 4 to an SWU symbol character
   * @function convert.code2swu
   * @param {number} code - Code point on plane 4
   * @returns {string} SWU symbol character
   * @example
   * convert.code2swu(0x40001)
   * 
   * return 'ñ€€'
   */
  const code2swu = code => String.fromCodePoint(code);

  /**
   * Function to convert an SWU symbol character to a 16-bit ID
   * @function convert.swu2id
   * @param {string} swuSym - SWU symbol character
   * @returns {number} 16-bit ID
   * @example
   * convert.swu2id('ñ€€')
   * 
   * return 1
   */
  const swu2id = swuSym => swu2code(swuSym) - 0x40000;

  /**
   * Function to convert a 16-bit ID to an SWU symbol character
   * @function convert.id2swu
   * @param {number} id - 16-bit ID
   * @returns {string} SWU symbol character
   * @example
   * convert.id2swu(1)
   * 
   * return 'ñ€€'
   */
  const id2swu = id => code2swu(id + 0x40000);

  /**
   * Function to convert an FSW symbol key to a 16-bit ID
   * @function convert.key2id
   * @param {string} key - FSW symbol key
   * @returns {number} 16-bit ID
   * @example
   * convert.key2id('S10000')
   * 
   * return 1
   */
  const key2id = key => key === "S00000" ? 0 : 1 + (parseInt(key.slice(1, 4), 16) - 256) * 96 + parseInt(key.slice(4, 5), 16) * 16 + parseInt(key.slice(5, 6), 16);

  /**
   * Function to convert a 16-bit ID to an FSW symbol key
   * @function convert.id2key
   * @param {number} id - 16-bit ID
   * @returns {string} FSW symbol key
   * @example
   * convert.id2key(1)
   * 
   * return 'S10000'
   */
  const id2key = id => {
    if (id === 0) {
      return "S00000";
    }
    const symcode = id - 1;
    const base = parseInt(symcode / 96);
    const fill = parseInt((symcode - base * 96) / 16);
    const rotation = parseInt(symcode - base * 96 - fill * 16);
    return 'S' + (base + 0x100).toString(16) + fill.toString(16) + rotation.toString(16);
  };

  /**
   * Function to convert an SWU symbol character to an FSW symbol key
   * @function convert.swu2key
   * @param {string} swuSym - SWU symbol character
   * @returns {string} FSW symbol key
   * @example
   * convert.swu2key('ñ€€')
   * 
   * return 'S10000'
   */
  const swu2key = swuSym => {
    if (swuSym === "ñ€€€") {
      return "S00000";
    }
    const symcode = swu2code(swuSym) - 0x40001;
    const base = parseInt(symcode / 96);
    const fill = parseInt((symcode - base * 96) / 16);
    const rotation = parseInt(symcode - base * 96 - fill * 16);
    return 'S' + (base + 0x100).toString(16) + fill.toString(16) + rotation.toString(16);
  };

  /**
   * Function to convert an FSW symbol key to an SWU symbol character
   * @function convert.key2swu
   * @param {string} key - FSW symbol key
   * @returns {string} SWU symbol character
   * @example
   * convert.key2swu('S10000')
   * 
   * return 'ñ€€'
   */
  const key2swu = key => {
    if (key === "S00000") {
      return code2swu(0x40000);
    }
    return code2swu(0x40001 + (parseInt(key.slice(1, 4), 16) - 256) * 96 + parseInt(key.slice(4, 5), 16) * 16 + parseInt(key.slice(5, 6), 16));
  };

  /**
   * Function to convert SWU text to FSW text
   * @function convert.swu2fsw
   * @param {string} swuText - SWU text
   * @returns {string} FSW text
   * @example
   * convert.swu2fsw('ð €ñ€€’ñ€€šñ‹š¥ñ‹›©ð ƒð¤Ÿð¤©ñ‹›©ð£µð¤ñ€€’ð¤‡ð£¤ñ‹š¥ð¤ð¤†ñ€€šð£®ð£­')
   * 
   * return 'AS10011S10019S2e704S2e748M525x535S2e748483x510S10011501x466S2e704510x500S10019476x475'
   */
  const swu2fsw = swuText => {
    if (!swuText) return '';
    let fsw = swuText.replace(/ð €/g, "A").replace(/ð /g, "B").replace(/ð ‚/g, "L").replace(/ð ƒ/g, "M").replace(/ð „/g, "R");
    const syms = fsw.match(new RegExp(re.nullorsymbol, 'g'));
    if (syms) {
      syms.forEach(function (sym) {
        fsw = fsw.replace(sym, swu2key(sym));
      });
    }
    const coords = fsw.match(new RegExp(re.coord, 'g'));
    if (coords) {
      coords.forEach(function (coord) {
        fsw = fsw.replace(coord, swu2coord(coord).join('x'));
      });
    }
    return fsw;
  };

  /**
   * Function to convert FSW text to SWU text
   * @function convert.fsw2swu
   * @param {string} fswText - FSW text
   * @returns {string} SWU text
   * @example
   * convert.fsw2swu('AS10011S10019S2e704S2e748M525x535S2e748483x510S10011501x466S2e704510x500S10019476x475')
   * 
   * return 'ð €ñ€€’ñ€€šñ‹š¥ñ‹›©ð ƒð¤Ÿð¤©ñ‹›©ð£µð¤ñ€€’ð¤‡ð£¤ñ‹š¥ð¤ð¤†ñ€€šð£®ð£­'
   */
  const fsw2swu = fswText => {
    if (!fswText) return '';
    const prefixes = fswText.match(new RegExp(re$1.prefix, 'g'));
    if (prefixes) {
      prefixes.forEach(function (prefix) {
        fswText = fswText.replace(prefix, 'ð €' + prefix.slice(1).match(/.{6}/g).map(key => key2swu(key)).join(''));
      });
    }
    const boxes = fswText.match(new RegExp(re$1.box + re$1.coord, 'g'));
    if (boxes) {
      boxes.forEach(function (boxes) {
        fswText = fswText.replace(boxes, mark2swu(boxes.slice(0, 1)) + coord2swu(fsw2coord(boxes.slice(1, 8))));
      });
    }
    const spatials = fswText.match(new RegExp(re$1.spatial, 'g'));
    if (spatials) {
      spatials.forEach(function (spatial) {
        fswText = fswText.replace(spatial, key2swu(spatial.slice(0, 6)) + coord2swu(fsw2coord(spatial.slice(6, 13))));
      });
    }
    return fswText;
  };

  /**
   * Function to convert base or full symid Min to symid Max
   * @function convert.symidMax
   * @param {string} symidMin - Symbol ID minimized
   * @returns {string} Symbol ID maximized
   * @example
   * convert.symidMax('101011')
   * 
   * return '01-01-001-01'
   * @example
   * convert.symidMax('101011616')
   * 
   * return '01-01-001-01-06-16'
   */
  const symidMax = symidMin => {
    if (!/^\d{6}(?:\d{3})?$/.test(symidMin)) {
      return '';
    }
    let max = `0${symidMin.charAt(0)}-${symidMin.charAt(1)}${symidMin.charAt(2)}-0${symidMin.charAt(3)}${symidMin.charAt(4)}-0${symidMin.charAt(5)}`;
    if (symidMin.length > 6) {
      max += `-0${symidMin.charAt(6)}-${symidMin.charAt(7)}${symidMin.charAt(8)}`;
    }
    return max;
  };

  /**
   * Function to convert base or full symid Max to symid Min
   * @function convert.symidMin
   * @param {string} symidMax - Symbol ID maximized
   * @returns {string} Symbol ID minimized
   * @example
   * convert.symidMin('01-01-001-01')
   * 
   * return '101011'
   * @example
   * convert.symidMin('01-01-001-01-06-16')
   * 
   * return '101011616'
   */
  const symidMin = symidMax => {
    const matches = symidMax.match(/^0(\d)-(\d{2})-0(\d{2})-0(\d)(?:-0(\d)-(\d{2}))?$/);
    if (!matches) {
      return '';
    }
    if (matches[5]) {
      return matches[1] + matches[2] + matches[3] + matches[4] + matches[5] + matches[6];
    } else {
      return matches[1] + matches[2] + matches[3] + matches[4];
    }
  };

  /**
   * Function to convert base or full symid to key
   * @function convert.symid2key
   * @param {string} symid - Symbol ID
   * @returns {string} Symbol key
   * @example
   * convert.symid2key('01-01-001-01')
   * 
   * return 'S100'
   * @example
   * convert.symid2key('01-01-001-01-06-16')
   * 
   * return 'S1005f'
   */
  const symid2key = symid => {
    const matches = symid.match(/^0(\d)-(\d{2})-0(\d{2})-0(\d)(?:-0(\d)-(\d{2}))?$/);
    if (!matches) {
      return '';
    }
    const symidMin = matches[1] + matches[2] + matches[3] + matches[4];
    const i = symidArr.indexOf(symidMin);
    if (i === -1) {
      return '';
    }
    if (matches[5]) {
      return 'S' + (256 + i).toString(16) + (parseInt(matches[5], 10) - 1) + (parseInt(matches[6], 10) - 1).toString(16);
    } else {
      return 'S' + (256 + i).toString(16);
    }
  };

  /**
   * Function to convert base or full key to symid
   * @function convert.key2symid
   * @param {string} key - Symbol key
   * @returns {string} Symbol ID
   * @example
   * convert.key2symid('S100')
   * 
   * return '01-01-001-01'
   * @example
   * convert.key2symid('S1005f')
   * 
   * return '01-01-001-01-06-16'
   */
  const key2symid = key => {
    const matches = key.match(/^S([1-3][0-9a-f]{2})(?:([0-5])([0-9a-f]))?$/);
    if (!matches) {
      return '';
    }
    const i = parseInt(matches[1], 16) - 256;
    if (i >= symidArr.length) {
      return '';
    }
    if (matches[3]) {
      return symidMax(symidArr[i]) + '-0' + (1 + parseInt(matches[2])) + '-' + (parseInt(matches[3], 16) + 1).toString().padStart(2, '0');
    } else {
      return symidMax(symidArr[i]);
    }
  };

  exports.code2swu = code2swu;
  exports.coord2fsw = coord2fsw;
  exports.coord2swu = coord2swu;
  exports.fsw2coord = fsw2coord;
  exports.fsw2swu = fsw2swu;
  exports.id2key = id2key;
  exports.id2swu = id2swu;
  exports.key2id = key2id;
  exports.key2swu = key2swu;
  exports.key2symid = key2symid;
  exports.mark2swu = mark2swu;
  exports.num2swu = num2swu;
  exports.swu2code = swu2code;
  exports.swu2coord = swu2coord;
  exports.swu2fsw = swu2fsw;
  exports.swu2id = swu2id;
  exports.swu2key = swu2key;
  exports.swu2mark = swu2mark;
  exports.swu2num = swu2num;
  exports.symid2key = symid2key;
  exports.symidArr = symidArr;
  exports.symidMax = symidMax;
  exports.symidMin = symidMin;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

/* support ongoing development */
/*   https://patreon.com/signwriting */
/*   https://donate.sutton-signwriting.io */
